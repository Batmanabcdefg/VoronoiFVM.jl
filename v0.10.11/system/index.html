<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System · VoronoiFVM.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VoronoiFVM.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changes/">Changes</a></li><li><a class="tocitem" href="../method/">The Voronoi finite volume method</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../physics/">Physics &amp; special functions</a></li><li class="is-active"><a class="tocitem" href>System</a><ul class="internal"><li><a class="tocitem" href="#Types-and-Constants"><span>Types and Constants</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../diffeq/">Interface to DifferentialEquations.jl</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../runexamples/">Running the examples</a></li><li><a class="tocitem" href="../examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../examples/Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../examples/Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../examples/Example120_ThreeRegions1D/">120: Differing species sets in regions, 1D</a></li><li><a class="tocitem" href="../examples/Example121_PoissonPointCharge1D/">121: 1D Poisson with point charge</a></li><li><a class="tocitem" href="../examples/Example125_TestFunctions1D/">125: Terminal flux calculation via test functions</a></li><li><a class="tocitem" href="../examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../examples/Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../examples/Example205_NonlinearPoisson2D/">205: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../examples/Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../examples/Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../examples/Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example405_GenericOperator/">405: Generic Operator: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../examples/TestDiffEq/">Comparison with DifferentialEquations.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>System</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-fu/VoronoiFVM.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h1><h2 id="Types-and-Constants"><a class="docs-heading-anchor" href="#Types-and-Constants">Types and Constants</a><a id="Types-and-Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Constants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.AbstractSystem" href="#VoronoiFVM.AbstractSystem"><code>VoronoiFVM.AbstractSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSystem{Tv&lt;:Number, Ti&lt;:Integer, Tm&lt;:Integer}</code></pre><p>Abstract type for finite volume system structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.DenseSolutionArray" href="#VoronoiFVM.DenseSolutionArray"><code>VoronoiFVM.DenseSolutionArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const DenseSolutionArray=Matrix</code></pre><p>Dense storage of solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.SparseSolutionArray" href="#VoronoiFVM.SparseSolutionArray"><code>VoronoiFVM.SparseSolutionArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SparseSolutionArray{Tv, Ti} &lt;: AbstractArray{Tv, 2}</code></pre><p>Struct holding solution information for SparseSystem. Solution is stored in a sparse matrix structure.</p><p>This class plays well with the abstract array interface.</p><p>Fields:</p><ul><li><p><code>node_dof::SparseArrays.SparseMatrixCSC{Tv, Ti} where {Tv, Ti}</code></p><p>Sparse matrix holding actual data.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.AbstractTransientSolution" href="#VoronoiFVM.AbstractTransientSolution"><code>VoronoiFVM.AbstractTransientSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractTransientSolution{T, N, A, B} &lt;: RecursiveArrayTools.AbstractDiffEqArray{T, N, A}</code></pre><p>Abstract type for transient solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.TransientSolution" href="#VoronoiFVM.TransientSolution"><code>VoronoiFVM.TransientSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct TransientSolution{T, N, A, B} &lt;: VoronoiFVM.AbstractTransientSolution{T, N, A, B}</code></pre><p>Transient solution structure</p><p><strong>Fields</strong></p><ul><li><p><code>u::Any</code></p><p>Vector of solutions</p></li></ul><ul><li><p><code>t::Any</code></p><p>Vector of times</p></li></ul><p><strong>Interface</strong></p><p>Object of this type adhere to the <code>AbstractDiffEqArray</code>  interface. For indexing and interpolation, see <a href="https://diffeq.sciml.ai/stable/basics/solution/">https://diffeq.sciml.ai/stable/basics/solution/</a>.</p><p>In particular, a TransientSolution <code>sol</code> can be accessed as follows:</p><ul><li><code>sol[it]</code> contains the solution for timestep <code>i</code></li><li><code>sol[ispec,:,it]</code> contains the solution for component <code>ispec</code> at timestep <code>i</code></li><li><code>sol(t)</code> returns a (linearly) interpolated solution value for <code>t</code>.</li><li><code>sol.t[it]</code> is the corresponding time</li><li><code>sol[ispec,ix,it]</code> refers to solution of component <code>ispec</code> at node <code>ix</code> at moment <code>it</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.TransientSolution-Union{Tuple{T}, Tuple{Number, AbstractArray{T, N} where N}} where T" href="#VoronoiFVM.TransientSolution-Union{Tuple{T}, Tuple{Number, AbstractArray{T, N} where N}} where T"><code>VoronoiFVM.TransientSolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TransientSolution(t0,inival;
                  in_memory=true,
                  keep_open=true,
                  fname=tempname(pwd())*&quot;.jld2&quot;</code></pre><p>Constructor of transient solution with initial value and inital time.</p><ul><li><code>in_memory</code>: if true (default), data are kept in main memory, otherwise on disk (via JLD2)</li><li><code>keep_open</code>: if true, disk file is not closed during the existence of the object</li><li><code>fname</code>: file name for the disk file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.VectorOfDiskArrays-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#VoronoiFVM.VectorOfDiskArrays-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>VoronoiFVM.VectorOfDiskArrays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VectorOfDiskArrays(firstobj:AbstractArray;
                   keep_open=true,
                   fname= fname=tempname(pwd())*&quot;.jld2&quot;)</code></pre><p>Constructor of vector of arrays stored on disk (via JLD2).</p><ul><li><code>keep_open</code>: if true, disk file is not closed during the existence of the object</li><li><code>fname</code>: file name for the disk file</li></ul><p>The disk file is automatically removed if the object is garbage collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.DenseSystem" href="#VoronoiFVM.DenseSystem"><code>VoronoiFVM.DenseSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct DenseSystem{Tv, Ti, Tm} &lt;: VoronoiFVM.AbstractSystem{Tv, Ti, Tm}</code></pre><p>Structure holding data for finite volume system solution. Information on species distribution is kept in dense matrices, and the solution array is of type Array{2}.</p><p>Unlike in the SparseSystem, the system matrix handles exactly those degrees of freedom which correspond to unknowns, and dummy  degrees of freedom where unknowns are not defined. Handling of the sparse matrix structures for the bookeeping of the unknowns has less overhead, but additional dummy equations are added to the system matrix.</p><ul><li><p><code>grid::Any</code></p><p>Grid</p></li></ul><ul><li><p><code>physics::VoronoiFVM.Physics</code></p><p>Physics data</p></li></ul><ul><li><p><code>boundary_values::Matrix{Tv} where Tv</code></p><p>Array of boundary values</p></li></ul><ul><li><p><code>boundary_factors::Matrix{Tv} where Tv</code></p><p>Array of boundary factors</p></li></ul><ul><li><p><code>region_species::Matrix{Int8}</code></p><p>Full matrix containing species numbers for inner regions</p></li></ul><ul><li><p><code>bregion_species::Matrix{Int8}</code></p><p>Full matrix containing species numbers for boundary regions</p></li></ul><ul><li><p><code>node_dof::Matrix{Int8}</code></p><p>Full matrix containing degree of freedom numbers for each node</p></li></ul><ul><li><p><code>matrix::ExtendableSparse.ExtendableSparseMatrix{Tv, Tm} where {Tv, Tm}</code></p><p>Jacobi matrix for nonlinear problem</p></li></ul><ul><li><p><code>species_homogeneous::Bool</code></p><p>Flag which says if the number of unknowns per node is constant</p></li></ul><ul><li><p><code>update::Matrix{Tv} where Tv</code></p><p>Solution vector holding Newton update</p></li></ul><ul><li><p><code>residual::Matrix{Tv} where Tv</code></p><p>Solution vector holding Newton residual</p></li></ul><ul><li><p><code>cellnodefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for cell nodes</p></li></ul><ul><li><p><code>celledgefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for cell edges</p></li></ul><ul><li><p><code>bfacenodefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for boundary nodes</p></li></ul><ul><li><p><code>generic_matrix::SparseArrays.SparseMatrixCSC</code></p><p>Sparse matrix for generic operator handling</p></li></ul><ul><li><p><code>generic_matrix_colors::Vector{T} where T</code></p><p>Sparse matrix colors for generic operator handling</p></li></ul><ul><li><p><code>uhash::UInt64</code></p><p>Hash value of latest unknowns vector the assembly was called with</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.DenseSystem-Tuple{Any, VoronoiFVM.Physics}" href="#VoronoiFVM.DenseSystem-Tuple{Any, VoronoiFVM.Physics}"><code>VoronoiFVM.DenseSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DenseSystem(grid::Any, physics::VoronoiFVM.Physics; matrixindextype) -&gt; VoronoiFVM.DenseSystem{_A, _B, Int32} where {_A, _B}
</code></pre><p>Constructor for DenseSystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.SparseSystem" href="#VoronoiFVM.SparseSystem"><code>VoronoiFVM.SparseSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SparseSystem{Tv, Ti, Tm} &lt;: VoronoiFVM.AbstractSystem{Tv, Ti, Tm}</code></pre><pre><code class="language-none">Structure holding data for finite volume system solution.</code></pre><p>Information on species distribution is kept in sparse matrices, and the solution array is of type SparseSolutionArray, i.e. effectively it is a sparse matrix.</p><p>Unlike in the DenseSystem, the system matrix handles exactly those degrees of freedom which correspond to unknowns. However, handling of the sparse matrix structures for the bookkeeping of the unknowns creates overhead.</p><ul><li><p><code>grid::Any</code></p><p>Grid</p></li></ul><ul><li><p><code>physics::VoronoiFVM.Physics</code></p><p>Physics data</p></li></ul><ul><li><p><code>boundary_values::Matrix{Tv} where Tv</code></p><p>Array of boundary values</p></li></ul><ul><li><p><code>boundary_factors::Matrix{Tv} where Tv</code></p><p>Array of boundary factors</p></li></ul><ul><li><p><code>region_species::SparseArrays.SparseMatrixCSC{Int8, Ti} where Ti</code></p><p>Sparse matrix containing species numbers for inner regions</p></li></ul><ul><li><p><code>bregion_species::SparseArrays.SparseMatrixCSC{Int8, Ti} where Ti</code></p><p>Sparse matrix containing species numbers for boundary regions</p></li></ul><ul><li><p><code>node_dof::SparseArrays.SparseMatrixCSC{Int8, Tm} where Tm</code></p><p>Sparse matrix containing degree of freedom numbers for each node</p></li></ul><ul><li><p><code>matrix::ExtendableSparse.ExtendableSparseMatrix{Tv, Tm} where {Tv, Tm}</code></p><p>Jacobi matrix for nonlinear problem</p></li></ul><ul><li><p><code>species_homogeneous::Bool</code></p><p>Flag which says if the number of unknowns per node is constant</p></li></ul><ul><li><p><code>update::VoronoiFVM.SparseSolutionArray{Tv, Tm} where {Tv, Tm}</code></p><p>Solution vector holding Newton update</p></li></ul><ul><li><p><code>residual::VoronoiFVM.SparseSolutionArray{Tv, Tm} where {Tv, Tm}</code></p><p>Solution vector holding Newton residual</p></li></ul><ul><li><p><code>cellnodefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for cell nodes</p></li></ul><ul><li><p><code>celledgefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for cell edges</p></li></ul><ul><li><p><code>bfacenodefactors::Matrix{Tv} where Tv</code></p><p>Precomputed geometry factors for boundary nodes</p></li></ul><ul><li><p><code>generic_matrix::SparseArrays.SparseMatrixCSC</code></p><p>Sparse matrix for generic operator handling</p></li></ul><ul><li><p><code>generic_matrix_colors::Vector{T} where T</code></p><p>Sparse matrix colors for generic operator handling</p></li></ul><ul><li><p><code>uhash::UInt64</code></p><p>Hash value of latest unknowns vector the assembly was called with</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.SparseSystem-Tuple{Any, VoronoiFVM.Physics}" href="#VoronoiFVM.SparseSystem-Tuple{Any, VoronoiFVM.Physics}"><code>VoronoiFVM.SparseSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SparseSystem(grid::Any, physics::VoronoiFVM.Physics; matrixindextype) -&gt; VoronoiFVM.SparseSystem{_A, _B, Int32} where {_A, _B}
</code></pre><p>Constructor for SparseSystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.BNode" href="#VoronoiFVM.BNode"><code>VoronoiFVM.BNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BNode{Tv, Ti} &lt;: VoronoiFVM.AbstractGeometryItem{Tv, Ti}</code></pre><p>Structure holding local boundary  node information.</p><ul><li><p><code>index::Any</code></p><p>Index in grid</p></li></ul><ul><li><p><code>region::Any</code></p><p>Boundary region number</p></li></ul><ul><li><p><code>nspec::Any</code></p><p>Number of species defined in node</p></li></ul><ul><li><p><code>coord::Matrix{Tv} where Tv</code></p><p>Grid coordinates</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.Edge" href="#VoronoiFVM.Edge"><code>VoronoiFVM.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Edge{Tv, Ti} &lt;: VoronoiFVM.AbstractGeometryItem{Tv, Ti}</code></pre><p>Structure holding local edge information.</p><ul><li><p><code>index::Any</code></p><p>Index in grid</p></li></ul><ul><li><p><code>node::Vector{Ti} where Ti</code></p><p>Index</p></li></ul><ul><li><p><code>region::Any</code></p><p>Inner region number corresponding to edge</p></li></ul><ul><li><p><code>nspec::Any</code></p><p>Number of species defined in edge</p></li></ul><ul><li><p><code>icell::Any</code></p><p>Number of discretization cell the edge is invoked from</p></li></ul><ul><li><p><code>coord::Matrix{Tv} where Tv</code></p><p>Grid coordinates</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.MatrixUnknowns" href="#VoronoiFVM.MatrixUnknowns"><code>VoronoiFVM.MatrixUnknowns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MatrixUnknowns{T} &lt;: AbstractArray{T, 2}</code></pre><p>Wrapper struct for viewing unknowns passed to flux as matrix</p><ul><li><p><code>u::Vector{T} where T</code></p></li><li><p><code>n1::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.Node" href="#VoronoiFVM.Node"><code>VoronoiFVM.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Node{Tv, Ti} &lt;: VoronoiFVM.AbstractGeometryItem{Tv, Ti}</code></pre><p>Structure holding local node information.</p><ul><li><p><code>index::Any</code></p><p>Index in grid</p></li></ul><ul><li><p><code>region::Any</code></p><p>Inner region number</p></li></ul><ul><li><p><code>nspec::Any</code></p><p>Number of species defined in node</p></li></ul><ul><li><p><code>icell::Any</code></p><p>Number of discretization cell the node is invoked from</p></li></ul><ul><li><p><code>coord::Matrix{Tv} where Tv</code></p><p>Grid coordinates</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.VectorUnknowns" href="#VoronoiFVM.VectorUnknowns"><code>VoronoiFVM.VectorUnknowns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct VectorUnknowns{T} &lt;: AbstractArray{T, 1}</code></pre><p>Wrapper struct for viewing unknowns passed to callback functions</p><ul><li><p><code>u::Vector{T} where T</code></p></li><li><p><code>n::Int64</code></p></li><li><p><code>offset::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.AssemblyError" href="#VoronoiFVM.AssemblyError"><code>VoronoiFVM.AssemblyError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AssemblyError &lt;: Exception</code></pre><p>Exception thrown if error occured during assembly (e.g. domain error)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.ConvergenceError" href="#VoronoiFVM.ConvergenceError"><code>VoronoiFVM.ConvergenceError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ConvergenceError &lt;: Exception</code></pre><p>Exception thrown if Newton&#39;s method convergence fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.EmbeddingError" href="#VoronoiFVM.EmbeddingError"><code>VoronoiFVM.EmbeddingError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EmbeddingError &lt;: Exception</code></pre><p>Exception thrown if embedding fails</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.FactorizationError" href="#VoronoiFVM.FactorizationError"><code>VoronoiFVM.FactorizationError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FactorizationError &lt;: Exception</code></pre><p>Exception thrown if error occured during factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.NewtonControl" href="#VoronoiFVM.NewtonControl"><code>VoronoiFVM.NewtonControl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct NewtonControl</code></pre><p>Control parameters for Newton method.</p><p>Newton&#39;s method solves <span>$F(u)=0$</span> by the iterative procedure <span>$u_{i+1}=u_{i} - d_i F&#39;(u_i)^{-1}F(u_i)$</span> starting with some inital value <span>$u_0$</span>, where <span>$d_i$</span> is the damping. </p><ul><li><p><code>tol_absolute::Float64</code></p><p>Tolerance (in terms of norm of Newton update): terminate if <span>$\Delta_i=||u_{i+1}-u_i||_\infty &lt;$</span> <code>tol_absolute</code>.</p><p>Default value: <code>1.0e-10</code>.</p></li></ul><ul><li><p><code>tol_relative::Float64</code></p><p>Tolerance (relative to the first residual): terminate if <span>$\Delta_i/\Delta_0&lt;$</span> <code>tol_relative</code>.</p><p>Default value: <code>1.0e-10</code>.</p></li></ul><ul><li><p><code>tol_round::Float64</code></p><p>Tolerance for roundoff error detection: terminate if   <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1&lt;$</span> <code>tol_round</code> occured <code>max_round</code> times in a row.</p><p>Default value: <code>1.0e-10</code>.</p></li></ul><ul><li><p><code>tol_mono::Float64</code></p><p>Tolerance for monotonicity test: terminat with error if <span>$\Delta_i/\Delta_{i-1}&gt;$</span> <code>1/tol_mono</code>.</p><p>Default value: 1.0e-3</p></li></ul><ul><li><p><code>damp_initial::Float64</code></p><p>Initial damping parameter <span>$d_0$</span>.</p><p>Default value: <code>1.0</code>.</p><p>To handle convergence problems, set this to a value less than 1.</p></li></ul><ul><li><p><code>damp_growth::Float64</code></p><p>Damping parameter growth factor: <span>$d_{i+1}=\min(d_i\cdot$</span> <code>max_growth</code> <span>$,1)$</span></p><p>Default value: <code>1.2</code></p><p>Generally it should be set to a value between 1 and 2.</p></li></ul><ul><li><p><code>max_iterations::Int32</code></p><p>Maximum number of iterations.</p><p>Default value: 100</p></li></ul><ul><li><p><code>max_lureuse::Int32</code></p><p>Maximum number of reuses of lu factorization. It this value is 0, linear systems are solved by a sparse direct solver, and it&#39;s LU factorization is called in every Newton step.</p><p>Otherwise, a BICGstab iterative method is used for linear system solution with an LU factorization as preconditioner which is updated only every <code>max_lureuse</code> Newton step.</p><p>Default value: 0.</p></li></ul><ul><li><p><code>max_round::Int32</code></p><p>Maximum number of consecutive iterations within roundoff error tolerance</p><p>Default value: 1000 (effectively switching of this criterion).</p></li></ul><ul><li><p><code>tol_linear::Float64</code></p><p>Tolerance of iterative linear solver.</p><p>Default value: <code>1.0e-4</code>.</p></li></ul><ul><li><p><code>verbose::Bool</code></p><p>Verbosity flag</p><p>Default value: <code>false</code>.</p></li></ul><ul><li><p><code>handle_exceptions::Bool</code></p><p>Handle exceptions in <a href="#VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>embed!</code></a> and  <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> methods. If <code>true</code>, exceptions in Newton solves are catched, the embedding resp. time step is lowered, and solution is retried.</p><p>Default value: <code>false</code></p></li></ul><ul><li><p><code>Δp::Float64</code></p><p>Initial parameter step for <a href="#VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>embed!</code></a> method.</p><p>Default value: <code>1.0</code></p></li></ul><ul><li><p><code>Δp_max::Float64</code></p><p>Maximal parameter step for <a href="#VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>embed!</code></a> method</p><p>Default value: <code>1.0</code></p></li></ul><ul><li><p><code>Δp_min::Float64</code></p><p>Minimal parameter step for <a href="#VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>embed!</code></a> method.</p><p>Default value: <code>1.0e-3</code></p></li></ul><ul><li><p><code>Δt::Float64</code></p><p>Time step for <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> method.</p><p>Default value: 0.1</p></li></ul><ul><li><p><code>Δt_max::Float64</code></p><p>Maximal time step for <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> method.</p><p>Default value: 1</p></li></ul><ul><li><p><code>Δt_min::Float64</code></p><p>Minimal time step for <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> method.</p><p>Default value: <code>1.0e-3</code></p></li></ul><ul><li><p><code>Δt_grow::Float64</code></p><p>Maximal step size growth for  <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> method.</p><p>Default: 1.2</p></li></ul><ul><li><p><code>Δu_opt::Float64</code></p><p>Optimal size of update for  <a href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>evolve!</code></a> method. The algorithm keeps this value approximately constant.</p><p>Default: 0.1</p></li></ul><ul><li><p><code>force_first_step::Bool</code></p><p>force first timestep</p></li></ul><ul><li><p><code>edge_cutoff::Float64</code></p><p>Edge cutoff for rectangular triangles.</p><p>Default value: <code>0.0</code>.</p></li></ul><ul><li><p><code>umfpack_pivot_tolerance::Float64</code></p><p>Pivot tolerance for umfpack</p><p>Default value: 0.1.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.NewtonControl-Tuple{Any}" href="#VoronoiFVM.NewtonControl-Tuple{Any}"><code>VoronoiFVM.NewtonControl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NewtonControl(this::Any) -&gt; Any
</code></pre><p>Default constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.TestFunctionFactory" href="#VoronoiFVM.TestFunctionFactory"><code>VoronoiFVM.TestFunctionFactory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct TestFunctionFactory{Tv}</code></pre><p>Data structure containing DenseSystem used to calculate test functions for boundary flux calculations.</p><ul><li><p><code>system::VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Tv, Ti&lt;:Integer, Tm&lt;:Integer}</code></p><p>Original system</p></li></ul><ul><li><p><code>tfsystem::VoronoiFVM.DenseSystem</code></p><p>Test function system</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.TestFunctionFactory-Union{Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}, Tuple{Tv}} where Tv" href="#VoronoiFVM.TestFunctionFactory-Union{Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}, Tuple{Tv}} where Tv"><code>VoronoiFVM.TestFunctionFactory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructor for TestFunctionFactory from System</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.Dirichlet" href="#VoronoiFVM.Dirichlet"><code>VoronoiFVM.Dirichlet</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Constant to be used as boundary condition factor  to mark Dirichlet boundary conditons.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.System-Tuple{Any, VoronoiFVM.Physics}" href="#VoronoiFVM.System-Tuple{Any, VoronoiFVM.Physics}"><code>VoronoiFVM.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(grid::Any, physics::VoronoiFVM.Physics; unknown_storage, matrixindextype) -&gt; Any
</code></pre><p>Create Finite Volume System. </p><ul><li><code>grid</code>: 1D/2D/3D discretization grid</li><li><code>physics</code>: Physics struct containing node and edge callbacks</li><li><code>unknown_storage</code>: string or symbol:<ul><li><code>:dense</code> :  solution vector is an  <code>nspecies</code> x <code>nnodes</code>  dense matrix</li><li><code>:sparse</code> :  solution vector is an <code>nspecies</code> x <code>nnodes</code>  sparse matrix</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.boundary_dirichlet!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any}" href="#VoronoiFVM.boundary_dirichlet!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any}"><code>VoronoiFVM.boundary_dirichlet!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundary_dirichlet!(this::VoronoiFVM.AbstractSystem, ispec::Integer, ibc::Integer, val::Any) -&gt; Any
</code></pre><p>Set Dirichlet boundary conditon for species ispec at boundary ibc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.boundary_neumann!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any}" href="#VoronoiFVM.boundary_neumann!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any}"><code>VoronoiFVM.boundary_neumann!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundary_neumann!(this::VoronoiFVM.AbstractSystem, ispec::Integer, ibc::Integer, val::Any) -&gt; Any
</code></pre><p>Set Neumann boundary conditon for species ispec at boundary ibc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.boundary_robin!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any, Any}" href="#VoronoiFVM.boundary_robin!-Tuple{VoronoiFVM.AbstractSystem, Integer, Integer, Any, Any}"><code>VoronoiFVM.boundary_robin!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundary_robin!(this::VoronoiFVM.AbstractSystem, ispec::Integer, ibc::Integer, fac::Any, val::Any) -&gt; Any
</code></pre><p>Set Robin boundary conditon for species ispec at boundary ibc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.data-Tuple{VoronoiFVM.AbstractSystem}" href="#VoronoiFVM.data-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">data(this::VoronoiFVM.AbstractSystem) -&gt; Any
</code></pre><p>Retrieve user data record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.enable_boundary_species!-Tuple{VoronoiFVM.AbstractSystem, Integer, AbstractVector{T} where T}" href="#VoronoiFVM.enable_boundary_species!-Tuple{VoronoiFVM.AbstractSystem, Integer, AbstractVector{T} where T}"><code>VoronoiFVM.enable_boundary_species!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_boundary_species!(this::VoronoiFVM.AbstractSystem, ispec::Integer, bregions::AbstractVector{T} where T)
</code></pre><p>Add species to a list of boundary regions. Species numbers for bulk and boundary species have to be distinct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.enable_species!-Tuple{VoronoiFVM.AbstractSystem, Integer, AbstractVector{T} where T}" href="#VoronoiFVM.enable_species!-Tuple{VoronoiFVM.AbstractSystem, Integer, AbstractVector{T} where T}"><code>VoronoiFVM.enable_species!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_species!(this::VoronoiFVM.AbstractSystem, ispec::Integer, regions::AbstractVector{T} where T)
</code></pre><p>Add species to a list of bulk regions. Species numbers for bulk and boundary species have to be distinct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.is_boundary_species-Tuple{VoronoiFVM.AbstractSystem, Integer}" href="#VoronoiFVM.is_boundary_species-Tuple{VoronoiFVM.AbstractSystem, Integer}"><code>VoronoiFVM.is_boundary_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_boundary_species(this::VoronoiFVM.AbstractSystem, ispec::Integer) -&gt; Bool
</code></pre><p>Check if species number corresponds to boundary species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.is_bulk_species-Tuple{VoronoiFVM.AbstractSystem, Integer}" href="#VoronoiFVM.is_bulk_species-Tuple{VoronoiFVM.AbstractSystem, Integer}"><code>VoronoiFVM.is_bulk_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_bulk_species(this::VoronoiFVM.AbstractSystem, ispec::Integer) -&gt; Bool
</code></pre><p>Check if species number corresponds bulk species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.isdof-Tuple{VoronoiFVM.AbstractSystem, Any, Any}" href="#VoronoiFVM.isdof-Tuple{VoronoiFVM.AbstractSystem, Any, Any}"><code>VoronoiFVM.isdof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdof(this::VoronoiFVM.AbstractSystem, ispec::Any, inode::Any) -&gt; Bool
</code></pre><p>Check if degree of freedom is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.num_species-Tuple{AbstractArray}" href="#VoronoiFVM.num_species-Tuple{AbstractArray}"><code>VoronoiFVM.num_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_species(a::AbstractArray) -&gt; Any
</code></pre><p>Number of species (size of first dimension) of solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.num_species-Tuple{VoronoiFVM.AbstractSystem}" href="#VoronoiFVM.num_species-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.num_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_species(this::VoronoiFVM.AbstractSystem) -&gt; Any
</code></pre><p>Number of species in system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.update_grid!-Union{Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#VoronoiFVM.update_grid!-Union{Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>VoronoiFVM.update_grid!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update grid (e.g. after rescaling of coordinates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.Grid" href="#VoronoiFVM.Grid"><code>VoronoiFVM.Grid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Grid=ExtendableGrids.simplexgrid</code></pre><p>Re-Export of ExtendableGrids.simplexgrid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.dof-Union{Tuple{Tv}, Tuple{Matrix{Tv}, Integer, Integer}} where Tv" href="#VoronoiFVM.dof-Union{Tuple{Tv}, Tuple{Matrix{Tv}, Integer, Integer}} where Tv"><code>VoronoiFVM.dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dof(a::Array{Tv, 2}, ispec::Integer, K::Integer) -&gt; Any
</code></pre><p>Get degree of freedom number</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.values-Union{Tuple{Matrix{Tv}}, Tuple{Tv}} where Tv" href="#VoronoiFVM.values-Union{Tuple{Matrix{Tv}}, Tuple{Tv}} where Tv"><code>VoronoiFVM.values</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Array of values in solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Base.copy-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a copy of solution array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{VoronoiFVM.SparseSolutionArray, Integer, Integer}" href="#Base.getindex-Tuple{VoronoiFVM.SparseSolutionArray, Integer, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(a::VoronoiFVM.SparseSolutionArray, ispec::Integer, inode::Integer) -&gt; Any
</code></pre><p>Accessor for solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer, Integer}" href="#Base.setindex!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer, Integer}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(a::VoronoiFVM.SparseSolutionArray, v::Any, ispec::Integer, inode::Integer) -&gt; Union{Nothing, VoronoiFVM.SparseSolutionArray}
</code></pre><p>Accessor for solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Base.similar-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a similar unintialized solution array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{VoronoiFVM.SparseSolutionArray}" href="#Base.size-Tuple{VoronoiFVM.SparseSolutionArray}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(a::VoronoiFVM.SparseSolutionArray) -&gt; Tuple{Int64, Int64}
</code></pre><p>Return size of solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.dof-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}, Integer, Integer}} where {Tv, Ti}" href="#VoronoiFVM.dof-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}, Integer, Integer}} where {Tv, Ti}"><code>VoronoiFVM.dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dof(a, i, j)
</code></pre><p>Get number of degree of freedom. Return 0 if species is not defined in node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.getdof-Tuple{VoronoiFVM.SparseSolutionArray, Integer}" href="#VoronoiFVM.getdof-Tuple{VoronoiFVM.SparseSolutionArray, Integer}"><code>VoronoiFVM.getdof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getdof(a::VoronoiFVM.SparseSolutionArray, i::Integer) -&gt; Any
</code></pre><p>Return  value for degree of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.setdof!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer}" href="#VoronoiFVM.setdof!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer}"><code>VoronoiFVM.setdof!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setdof!(a::VoronoiFVM.SparseSolutionArray, v::Any, i::Integer) -&gt; Any
</code></pre><p>Set value for degree of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.values-Tuple{VoronoiFVM.SparseSolutionArray}" href="#VoronoiFVM.values-Tuple{VoronoiFVM.SparseSolutionArray}"><code>VoronoiFVM.values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">values(a::VoronoiFVM.SparseSolutionArray) -&gt; Vector{Tv} where Tv
</code></pre><p>Array of values in solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Union{Tuple{Tv}, Tuple{Tu}, Tuple{AbstractVector{Tu}, VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}} where {Tu, Tv}" href="#Base.reshape-Union{Tuple{Tv}, Tuple{Tu}, Tuple{AbstractVector{Tu}, VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}} where {Tu, Tv}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape(v, sys)
</code></pre><p>Reshape vector to fit as solution to system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{VoronoiFVM.DenseSystem, Any, Any}" href="#LinearAlgebra.norm-Tuple{VoronoiFVM.DenseSystem, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.num_dof-Tuple{VoronoiFVM.DenseSystem}" href="#VoronoiFVM.num_dof-Tuple{VoronoiFVM.DenseSystem}"><code>VoronoiFVM.num_dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_dof(this::VoronoiFVM.DenseSystem) -&gt; Int64
</code></pre><p>Number of degrees of freedom for system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{Tv}, Tuple{Type, VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}} where Tv" href="#VoronoiFVM.unknowns-Union{Tuple{Tv}, Tuple{Type, VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}} where Tv"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(Tu::Type, sys::VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}; inival) -&gt; Any
</code></pre><p>Create a solution vector for dense system. If inival is not specified, the entries of the returned vector are undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}, Tuple{Tv}} where Tv" href="#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.DenseSystem{Tv, Ti, Tm} where {Ti, Tm}}, Tuple{Tv}} where Tv"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a solution vector for dense system. If inival is not specified, the entries of the returned vector are undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{AbstractVector{Tu}, VoronoiFVM.SparseSystem{Tv, Ti, Tm}}} where {Tu, Tv, Ti, Tm}" href="#Base.reshape-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{AbstractVector{Tu}, VoronoiFVM.SparseSystem{Tv, Ti, Tm}}} where {Tu, Tv, Ti, Tm}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape(v, sys)
</code></pre><p>Reshape vector to fit as solution to system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.num_dof-Tuple{VoronoiFVM.SparseSystem}" href="#VoronoiFVM.num_dof-Tuple{VoronoiFVM.SparseSystem}"><code>VoronoiFVM.num_dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_dof(this::VoronoiFVM.SparseSystem) -&gt; Any
</code></pre><p>Number of degrees of freedom for system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Type, VoronoiFVM.SparseSystem{Tv, Ti, Tm}}} where {Tv, Ti, Tm}" href="#VoronoiFVM.unknowns-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Type, VoronoiFVM.SparseSystem{Tv, Ti, Tm}}} where {Tv, Ti, Tm}"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(Tu, sys; inival)
</code></pre><p>Create a solution vector for sparse system with given type. If inival is not specified, the entries of the returned vector are undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.SparseSystem{Tv, Ti, Tm}}, Tuple{Tm}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, Tm}" href="#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.SparseSystem{Tv, Ti, Tm}}, Tuple{Tm}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, Tm}"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a solution vector for sparse system.  The entries of the returned vector are undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.meas-Tuple{VoronoiFVM.Edge}" href="#VoronoiFVM.meas-Tuple{VoronoiFVM.Edge}"><code>VoronoiFVM.meas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meas(edge::VoronoiFVM.Edge) -&gt; Any
</code></pre><p>Calculate the length of an edge. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.num_species-Tuple{VoronoiFVM.Edge}" href="#VoronoiFVM.num_species-Tuple{VoronoiFVM.Edge}"><code>VoronoiFVM.num_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_species(edge::VoronoiFVM.Edge) -&gt; Any
</code></pre><p>Return number of species for edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Tuple{VoronoiFVM.BNode, Any}" href="#VoronoiFVM.unknowns-Tuple{VoronoiFVM.BNode, Any}"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(node::VoronoiFVM.BNode, u::Any) -&gt; Any
</code></pre><p>Construct vector unknowns on bnode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Tuple{VoronoiFVM.Node, Any}" href="#VoronoiFVM.unknowns-Tuple{VoronoiFVM.Node, Any}"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(node::VoronoiFVM.Node, u::Any) -&gt; Any
</code></pre><p>Construct vector unknowns on node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{T}, Tuple{VoronoiFVM.Edge, Vector{T}, Any}} where T" href="#VoronoiFVM.unknowns-Union{Tuple{T}, Tuple{VoronoiFVM.Edge, Vector{T}, Any}} where T"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(edge::VoronoiFVM.Edge, u::Array{T, 1}, i::Any) -&gt; VoronoiFVM.VectorUnknowns{_A} where _A
</code></pre><p>Construct vector unknowns on edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.unknowns-Union{Tuple{T}, Tuple{VoronoiFVM.Edge, Vector{T}}} where T" href="#VoronoiFVM.unknowns-Union{Tuple{T}, Tuple{VoronoiFVM.Edge, Vector{T}}} where T"><code>VoronoiFVM.unknowns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unknowns(edge::VoronoiFVM.Edge, u::Array{T, 1}) -&gt; VoronoiFVM.MatrixUnknowns{_A} where _A
</code></pre><p>Construct matrix of unknowns from edge - these can be used in flux functions with the v0.7.x and v0.8.x syntax to acces data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.viewK-Tuple{VoronoiFVM.Edge, Any}" href="#VoronoiFVM.viewK-Tuple{VoronoiFVM.Edge, Any}"><code>VoronoiFVM.viewK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewK(edge::VoronoiFVM.Edge, u::Any) -&gt; VoronoiFVM.VectorUnknowns{_A} where _A
</code></pre><p>Solution view on first edge node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.viewL-Tuple{VoronoiFVM.Edge, Any}" href="#VoronoiFVM.viewL-Tuple{VoronoiFVM.Edge, Any}"><code>VoronoiFVM.viewL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewL(edge::VoronoiFVM.Edge, u::Any) -&gt; VoronoiFVM.VectorUnknowns{_A} where _A
</code></pre><p>Solution view on second edge node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv" href="#VoronoiFVM.embed!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>VoronoiFVM.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function embed!(solution, inival, system; 
                control=NewtonControl(),
                pre=function(sol,p) end,
                post=function(sol,p) end
)</code></pre><p>Solve stationary problem via parameter embedding, calling <code>solve!</code> for increasing values of the parameter p from interval (0,1). The user is responsible for the interpretation of the parameter. The optional <code>pre()</code> callback can be used to communicate its value to the system. The optional <code>post()</code> callback method can be used to perform various postprocessing steps.</p><p>If <code>control.handle_error</code> is true, <code>solve!</code>  throws an error, and stepsize <code>control.Δp</code> is lowered, and <code>solve!</code> is called again with a smaller  parameter value. If <code>control.Δp&lt;control.Δp_min</code>, <code>embed!</code> is aborted with error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.eval_and_assemble-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, AbstractMatrix{Tv}, AbstractMatrix{Tv}, AbstractMatrix{Tv}, Tv}} where {Tv, Ti}" href="#VoronoiFVM.eval_and_assemble-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, AbstractMatrix{Tv}, AbstractMatrix{Tv}, AbstractMatrix{Tv}, Tv}} where {Tv, Ti}"><code>VoronoiFVM.eval_and_assemble</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_and_assemble(system, U, UOld, F, tstep; edge_cutoff)
</code></pre><p>Main assembly method.</p><p>Evaluate solution with result in right hand side F and  assemble matrix into system.matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv" href="#VoronoiFVM.evolve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}, AbstractVector{T} where T}} where Tv"><code>VoronoiFVM.evolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function evolve!(solution, inival, system, times;
                 control=NewtonControl(), 
                 pre=function(sol,t) end,   
                 post=function(sol,oldsol, t, Δt) end,
                 sample=function(sol,t) end,
                 delta=(u,v,t, Δt)-&gt;norm(sys,u-v,Inf)
)</code></pre><p>Use implicit Euler method  + damped   Newton&#39;s method  to  solve time dependent problem. Time step control is performed according to the data in <code>control</code>.  All times in <code>times</code> are reached exactly.</p><p>Callbacks:</p><ul><li><code>pre</code> is invoked before each time step</li><li><code>post</code>  is invoked after each time step</li><li><code>sample</code> is called for all times in <code>times[2:end]</code>.</li></ul><p><code>delta</code> is  used to control the time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.integrate-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm}, Function, AbstractMatrix{Tu}}} where {Tu, Tv, Ti, Tm}" href="#VoronoiFVM.integrate-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm}, Function, AbstractMatrix{Tu}}} where {Tu, Tv, Ti, Tm}"><code>VoronoiFVM.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate(system,F,U; boundary=false)    </code></pre><p>Integrate node function (same signature as reaction or storage)  <code>F</code> of  solution vector over domain or boundary  The result contains the integral for each species separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.solve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv" href="#VoronoiFVM.solve!-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>VoronoiFVM.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(solution, inival, system; control=NewtonControl(),tstep=Inf, log=false)</code></pre><p>Perform solution of stationary problem(if <code>tstep==Inf</code>) or one step of the implicit Euler method using Newton&#39;s method with <code>inival</code> as initial value. The method writes into <code>solution</code>. </p><p>It returns <code>solution</code> or, if <code>log==true</code>, a tuple of solution and a vector containing the residual history of Newton&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.solve-Tuple{AbstractMatrix{T} where T, VoronoiFVM.AbstractSystem, AbstractVector{T} where T}" href="#VoronoiFVM.solve-Tuple{AbstractMatrix{T} where T, VoronoiFVM.AbstractSystem, AbstractVector{T} where T}"><code>VoronoiFVM.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function solve(inival, system, times;
               control=NewtonControl(), 
               pre=function(sol,t) end,   
               post=function(sol,oldsol, t, Δt) end,
               sample=function(sol,t) end,
               delta=(u,v,t, Δt)-&gt;norm(sys,u-v,Inf),
               store_all=true,
               in_memory=true
)</code></pre><p>Use implicit Euler method  + damped   Newton&#39;s method  to  solve time dependent problem. Time step control is performed according to the data in <code>control</code>.  All times in <code>times</code> are reached exactly.</p><p>Callbacks:</p><ul><li><code>pre</code> is invoked before each time step</li><li><code>post</code>  is invoked after each time step</li><li><code>sample</code> is called for all times in <code>times[2:end]</code>.</li></ul><p><code>delta</code> is  used to control the time step.</p><p>If <code>store_all==true</code>, all timestep solutions are stored. Otherwise, only solutions for the elements of <code>times</code> are stored.</p><p>Returns a transient solution object <code>sol</code> containing stored solutions, see <a href="#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.solve-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv" href="#VoronoiFVM.solve-Union{Tuple{Tv}, Tuple{AbstractMatrix{Tv}, VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where {Ti&lt;:Integer, Tm&lt;:Integer}}} where Tv"><code>VoronoiFVM.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(inival, system; control=NewtonControl(), tstep=Inf, log=false)</code></pre><p>Perform solution of stationary problem(if <code>tstep==Inf</code>) or one step of the implicit Euler method using Newton&#39;s method with <code>inival</code> as initial value. The method writes into <code>solution</code>. </p><p>It returns a solution array or, if <code>log==true</code>, a tuple of solution and a vector containing the residual history of Newton&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.value" href="#VoronoiFVM.value"><code>VoronoiFVM.value</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Extract value from dual number. Use to debug physics callbacks. Re-exported from ForwardDiff.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.fixed_timesteps!-Tuple{Any, Any}" href="#VoronoiFVM.fixed_timesteps!-Tuple{Any, Any}"><code>VoronoiFVM.fixed_timesteps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">timesteps!(control,Δt; grow=1.0)</code></pre><p>Modify control data such that the time steps are fixed to a geometric sequence such that Δt<em>new=Δt</em>old*grow</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tv}, AbstractMatrix{Tv}, Real}} where {Tv, Ti}" href="#VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tv}, AbstractMatrix{Tv}, Real}} where {Tv, Ti}"><code>VoronoiFVM.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate(this, tf, U, Uold, tstep)
</code></pre><p>Calculate test function integral for transient solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tv}}} where {Tv, Ti}" href="#VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tv}}} where {Tv, Ti}"><code>VoronoiFVM.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate(this, tf, U)
</code></pre><p>Calculate test function integral for steady state solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.integrate_stdy-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}" href="#VoronoiFVM.integrate_stdy-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}"><code>VoronoiFVM.integrate_stdy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate_stdy(this, tf, U)
</code></pre><p>Steady state part of test function integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.integrate_tran-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}" href="#VoronoiFVM.integrate_tran-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm} where Tm&lt;:Integer, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}"><code>VoronoiFVM.integrate_tran</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate transient part of test function integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.testfunction-Union{Tuple{Tv}, Tuple{VoronoiFVM.TestFunctionFactory{Tv}, Any, Any}} where Tv" href="#VoronoiFVM.testfunction-Union{Tuple{Tv}, Tuple{VoronoiFVM.TestFunctionFactory{Tv}, Any, Any}} where Tv"><code>VoronoiFVM.testfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testfunction(factory::VoronoiFVM.TestFunctionFactory{Tv}, bc0::Any, bc1::Any) -&gt; Any
</code></pre><p>Create testfunction which has Dirichlet zero boundary conditions  for boundary regions in bc0 and Dirichlet one boundary conditions  for boundary regions in bc1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../physics/">« Physics &amp; special functions</a><a class="docs-footer-nextpage" href="../diffeq/">Interface to DifferentialEquations.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 March 2021 16:11">Friday 26 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
